# Data
E1 = [1.7, 1, 4, -1]
E2 = [5.5, 2, 9, +1]
E3 = [2.2, 5, 6, +1]
E4 = [1.3, 4, 5, +1]
E5 = [1.4, 6, 0.7, -1]
E6 = [4.2, 1, 1.5, -1]
E_list = [E1, E2, E3, E4, E5, E6]

# Learning Algorithm Function 
def learning_algorithm(x1, x2, x3, class_value, w0, w1, w2, w3):
    classification = False
    while not classification:
        dotProduct = w0 + (w1*x1) + (w2*x2) + (w3*x3)
        if class_value == 1 and dotProduct <= 0:
            w0 += class_value
            w1 += class_value * x1
            w2 += class_value * x2
            w3 += class_value * x3
        elif class_value == -1 and dotProduct >= 0:
            w0 += class_value
            w1 += class_value * x1
            w2 += class_value * x2
            w3 += class_value * x3
        else:
            classification = True
    return w0, w1, w2, w3, f"w.x = {w0} + ({w1})x1 + ({w2})x2 + ({w3})x3"

# Initial weights
w0, w1, w2, w3 = 0, 0, 0, 0

# Iterate until weights become stable
weights_changed = True
iteration = 0
while weights_changed:
    weights_before = [w0, w1, w2, w3]
    for i, E in enumerate(E_list):
        x1, x2, x3, class_value = E[0], E[1], E[2], E[3]
        w0, w1, w2, w3, equation = learning_algorithm(x1, x2, x3, class_value, w0, w1, w2, w3)
        print(f"Iteration {iteration + 1}, Row {i+1}: {equation}")
    weights_after = [w0, w1, w2, w3]
    
    if weights_before == weights_after:
        weights_changed = False
    iteration += 1

print("\nWeights have stabilised.")